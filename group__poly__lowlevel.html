<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Libpolycomp: Polynomial compression (low-level functions)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libpolycomp
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A compression/decompression library that implements the polynomial compression and other simple compression schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__poly__lowlevel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polynomial compression (low-level functions)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18386cb1be87dc5f53c412d597496a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga18386cb1be87dc5f53c412d597496a56">pcomp_polycomp_forward_cheby</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga18386cb1be87dc5f53c412d597496a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a pcomp_chebyshev_t structure representing the forward Chebyshev transform.  <a href="#ga18386cb1be87dc5f53c412d597496a56">More...</a><br /></td></tr>
<tr class="separator:ga18386cb1be87dc5f53c412d597496a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af675aacf01f812bda7244f488771a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga9af675aacf01f812bda7244f488771a3">pcomp_polycomp_backward_cheby</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga9af675aacf01f812bda7244f488771a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a pcomp_chebyshev_t structure representing the forward Chebyshev transform.  <a href="#ga9af675aacf01f812bda7244f488771a3">More...</a><br /></td></tr>
<tr class="separator:ga9af675aacf01f812bda7244f488771a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29ad7a7a070d4e13bc7ab2788b914a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gaf29ad7a7a070d4e13bc7ab2788b914a9">pcomp_straighten</a> (double *output, const double *input, size_t num_of_samples, double period)</td></tr>
<tr class="memdesc:gaf29ad7a7a070d4e13bc7ab2788b914a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sudden jumps from <em>input</em>.  <a href="#gaf29ad7a7a070d4e13bc7ab2788b914a9">More...</a><br /></td></tr>
<tr class="separator:gaf29ad7a7a070d4e13bc7ab2788b914a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43fbe9e5919993793a6d6bc21052db0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga43fbe9e5919993793a6d6bc21052db0a">pcomp_init_chunk</a> (pcomp_chunk_size_t num_of_samples)</td></tr>
<tr class="memdesc:ga43fbe9e5919993793a6d6bc21052db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a pcomp_polycomp_chunk_t object.  <a href="#ga43fbe9e5919993793a6d6bc21052db0a">More...</a><br /></td></tr>
<tr class="separator:ga43fbe9e5919993793a6d6bc21052db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f80a1f4ebc88b78e077911f7609252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga28f80a1f4ebc88b78e077911f7609252">pcomp_init_uncompressed_chunk</a> (pcomp_chunk_size_t num_of_samples, const double *samples)</td></tr>
<tr class="memdesc:ga28f80a1f4ebc88b78e077911f7609252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a pcomp_polycomp_chunk_t object and fill it with data in uncompressed form.  <a href="#ga28f80a1f4ebc88b78e077911f7609252">More...</a><br /></td></tr>
<tr class="separator:ga28f80a1f4ebc88b78e077911f7609252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff14c414978ab762b24993b7e607a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga0ff14c414978ab762b24993b7e607a2e">pcomp_init_compressed_chunk</a> (pcomp_chunk_size_t num_of_samples, pcomp_poly_size_t num_of_poly_coeffs, const double *poly_coeffs, pcomp_chunk_size_t num_of_cheby_coeffs, const uint8_t *cheby_mask, const double *cheby_coeffs)</td></tr>
<tr class="memdesc:ga0ff14c414978ab762b24993b7e607a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a pcomp_polycomp_chunk_t object and fill it with data compressed using the polynomial compression algorithm.  <a href="#ga0ff14c414978ab762b24993b7e607a2e">More...</a><br /></td></tr>
<tr class="separator:ga0ff14c414978ab762b24993b7e607a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50ddd62f855c2dfc1bc96ff00d5749e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gaf50ddd62f855c2dfc1bc96ff00d5749e">pcomp_free_chunk</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:gaf50ddd62f855c2dfc1bc96ff00d5749e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory associated with a pcomp_poly_chunk_t.  <a href="#gaf50ddd62f855c2dfc1bc96ff00d5749e">More...</a><br /></td></tr>
<tr class="separator:gaf50ddd62f855c2dfc1bc96ff00d5749e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141568816a3a902b8575be472e63ea4b"><td class="memItemLeft" align="right" valign="top">pcomp_chunk_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga141568816a3a902b8575be472e63ea4b">pcomp_chunk_num_of_samples</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga141568816a3a902b8575be472e63ea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of samples in a chunk.  <a href="#ga141568816a3a902b8575be472e63ea4b">More...</a><br /></td></tr>
<tr class="separator:ga141568816a3a902b8575be472e63ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf216d8d9fd3b321ff894348ee6db048f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gaf216d8d9fd3b321ff894348ee6db048f">pcomp_chunk_num_of_bytes</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:gaf216d8d9fd3b321ff894348ee6db048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes necessary to encode a chunk.  <a href="#gaf216d8d9fd3b321ff894348ee6db048f">More...</a><br /></td></tr>
<tr class="separator:gaf216d8d9fd3b321ff894348ee6db048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c68ca23c00d0c68290cbee421b46959"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c68ca23c00d0c68290cbee421b46959"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga6c68ca23c00d0c68290cbee421b46959">pcomp_chunk_is_compressed</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga6c68ca23c00d0c68290cbee421b46959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return nonzero if the chunk holds data in uncompressed form. <br /></td></tr>
<tr class="separator:ga6c68ca23c00d0c68290cbee421b46959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484af052733f1b0d51fc6ca881378a48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga484af052733f1b0d51fc6ca881378a48"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga484af052733f1b0d51fc6ca881378a48">pcomp_chunk_uncompressed_data</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga484af052733f1b0d51fc6ca881378a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the chunks contain uncompressed data, returns a pointer to the first element. Otherwise, return <code>NULL</code>. <br /></td></tr>
<tr class="separator:ga484af052733f1b0d51fc6ca881378a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7547592c7b14173dafd69fa488177a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7547592c7b14173dafd69fa488177a17"></a>
pcomp_poly_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga7547592c7b14173dafd69fa488177a17">pcomp_chunk_num_of_poly_coeffs</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga7547592c7b14173dafd69fa488177a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the chunks contain compressed data, returns the number of polynomial coefficients used in the compression. Otherwise, return zero. <br /></td></tr>
<tr class="separator:ga7547592c7b14173dafd69fa488177a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a18b73c465cf2d7272697b5ad47f00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99a18b73c465cf2d7272697b5ad47f00"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga99a18b73c465cf2d7272697b5ad47f00">pcomp_chunk_poly_coeffs</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga99a18b73c465cf2d7272697b5ad47f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the chunks contain compressed data, returns a pointer to the first element of the array of coefficients of the interpolating polynomial. Otherwise, return <code>NULL</code>. <br /></td></tr>
<tr class="separator:ga99a18b73c465cf2d7272697b5ad47f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55d42fa84ab4ed1ffcaec8586780d74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab55d42fa84ab4ed1ffcaec8586780d74"></a>
pcomp_chunk_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gab55d42fa84ab4ed1ffcaec8586780d74">pcomp_chunk_num_of_cheby_coeffs</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:gab55d42fa84ab4ed1ffcaec8586780d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the chunks contain compressed data, returns the number of nonzero Chebyshev coefficients held in the chunk. Otherwise, return zero. <br /></td></tr>
<tr class="separator:gab55d42fa84ab4ed1ffcaec8586780d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35031f8a7cf52240cfb523dc61cfd32e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35031f8a7cf52240cfb523dc61cfd32e"></a>
const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga35031f8a7cf52240cfb523dc61cfd32e">pcomp_chunk_cheby_coeffs</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga35031f8a7cf52240cfb523dc61cfd32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the chunks contain compressed data, returns a pointer to the first element of the Chebyshev transform of the fit residuals. Otherwise, return <code>NULL</code>. <br /></td></tr>
<tr class="separator:ga35031f8a7cf52240cfb523dc61cfd32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278cdcfa644b93f84559f9827e29457f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga278cdcfa644b93f84559f9827e29457f">pcomp_chunk_cheby_mask_size</a> (pcomp_chunk_size_t chunk_size)</td></tr>
<tr class="memdesc:ga278cdcfa644b93f84559f9827e29457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes required for the bitmask of nonzero Chebyshev coefficients.  <a href="#ga278cdcfa644b93f84559f9827e29457f">More...</a><br /></td></tr>
<tr class="separator:ga278cdcfa644b93f84559f9827e29457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8874e60b925bcd6720b87f35bf1e667d"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga8874e60b925bcd6720b87f35bf1e667d">pcomp_chunk_cheby_mask</a> (const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk)</td></tr>
<tr class="memdesc:ga8874e60b925bcd6720b87f35bf1e667d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the bitmask of nonzero Chebyshev coefficients for a chunk.  <a href="#ga8874e60b925bcd6720b87f35bf1e667d">More...</a><br /></td></tr>
<tr class="separator:ga8874e60b925bcd6720b87f35bf1e667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c82bb784b5207c2699b1db70d985ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga30c82bb784b5207c2699b1db70d985ea">pcomp_polyfit_and_chebyshev</a> (<a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params, double *coeffs, double *cheby_residuals, const double *input, double *max_residual)</td></tr>
<tr class="memdesc:ga30c82bb784b5207c2699b1db70d985ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a polynomial fit of the data in <em>input</em> and a Chebyshev transform of the residuals.  <a href="#ga30c82bb784b5207c2699b1db70d985ea">More...</a><br /></td></tr>
<tr class="separator:ga30c82bb784b5207c2699b1db70d985ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab793c0d3bc98503acefd4c4d095ddd45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gab793c0d3bc98503acefd4c4d095ddd45">pcomp_mask_get_bit</a> (const uint8_t *mask, size_t pos)</td></tr>
<tr class="memdesc:gab793c0d3bc98503acefd4c4d095ddd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the bit at the position <em>pos</em> in the bitmask <em>mask</em>.  <a href="#gab793c0d3bc98503acefd4c4d095ddd45">More...</a><br /></td></tr>
<tr class="separator:gab793c0d3bc98503acefd4c4d095ddd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21094e8f3ade1288b47870b9c45c879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gad21094e8f3ade1288b47870b9c45c879">pcomp_mask_set_bit</a> (uint8_t *mask, size_t pos, int value)</td></tr>
<tr class="memdesc:gad21094e8f3ade1288b47870b9c45c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the bit at position <em>pos</em> in the bitmask <em></em>.  <a href="#gad21094e8f3ade1288b47870b9c45c879">More...</a><br /></td></tr>
<tr class="separator:gad21094e8f3ade1288b47870b9c45c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2ff8322ae622908407d94ac1873317"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gabf2ff8322ae622908407d94ac1873317">pcomp_find_chebyshev_mask</a> (<a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *chebyshev, <a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *inv_chebyshev, double max_allowable_error, uint8_t *mask, double *max_error)</td></tr>
<tr class="memdesc:gabf2ff8322ae622908407d94ac1873317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest subset of Chebyshev coefficients that can approximate a Chebyshev transform with an error less than <em>max_allowable_error</em>.  <a href="#gabf2ff8322ae622908407d94ac1873317">More...</a><br /></td></tr>
<tr class="separator:gabf2ff8322ae622908407d94ac1873317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16fd7dc37524f6a0ba57d29ca766a54d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#ga16fd7dc37524f6a0ba57d29ca766a54d">pcomp_run_polycomp_on_chunk</a> (<a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params, const double *input, pcomp_chunk_size_t num_of_samples, <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk, double *max_error)</td></tr>
<tr class="memdesc:ga16fd7dc37524f6a0ba57d29ca766a54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the first <em>num_of_samples</em> elements in <em>input</em> and store them in <em>chunk</em>.  <a href="#ga16fd7dc37524f6a0ba57d29ca766a54d">More...</a><br /></td></tr>
<tr class="separator:ga16fd7dc37524f6a0ba57d29ca766a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2227fe2823fe2ce04d9c1a1d99dc294"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly__lowlevel.html#gae2227fe2823fe2ce04d9c1a1d99dc294">pcomp_decompress_polycomp_chunk</a> (double *output, const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk, <a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *inv_chebyshev)</td></tr>
<tr class="memdesc:gae2227fe2823fe2ce04d9c1a1d99dc294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress the data in a chunk.  <a href="#gae2227fe2823fe2ce04d9c1a1d99dc294">More...</a><br /></td></tr>
<tr class="separator:gae2227fe2823fe2ce04d9c1a1d99dc294"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8874e60b925bcd6720b87f35bf1e667d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* pcomp_chunk_cheby_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the bitmask of nonzero Chebyshev coefficients for a chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Pointer to the chunk</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the array of bytes which make up the mask. Use <a class="el" href="group__poly__lowlevel.html#gab793c0d3bc98503acefd4c4d095ddd45">pcomp_mask_get_bit</a> to access the values of each bit. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01312">1312</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga278cdcfa644b93f84559f9827e29457f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcomp_chunk_cheby_mask_size </td>
          <td>(</td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes required for the bitmask of nonzero Chebyshev coefficients. </p>
<p>The polynomial compression compresses Chebyshev transforms by saving only those coefficients that are significantly different from zero. In order to keep track of the position of such coefficients in the full array, a bit mask is used. This function determines how many bytes are required for such mask, which is internally represented by Libpolycomp as an array of <code>uint8_t</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_size</td><td>Number of samples in the chunk</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes (<code>uint8_t</code> values) required for the mask. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01295">1295</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf216d8d9fd3b321ff894348ee6db048f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcomp_chunk_num_of_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes necessary to encode a chunk. </p>
<p>Refer to <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a> and <a class="el" href="group__poly.html#ga388baf20639fc3adca5debcf62f03046">pcomp_decode_chunks</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Pointer to the chunk data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01143">1143</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga141568816a3a902b8575be472e63ea4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcomp_chunk_size_t pcomp_chunk_num_of_samples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of samples in a chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Pointer to the chunk data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01124">1124</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae2227fe2823fe2ce04d9c1a1d99dc294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_decompress_polycomp_chunk </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *&#160;</td>
          <td class="paramname"><em>inv_chebyshev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompress the data in a chunk. </p>
<p>This function performs the decompression of a chunk, and it is the counterpart of <a class="el" href="group__poly__lowlevel.html#ga16fd7dc37524f6a0ba57d29ca766a54d">pcomp_run_polycomp_on_chunk</a>. Here is an example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>* decompr;</div>
<div class="line"><a class="code" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a>* inv_chebyshev;</div>
<div class="line"></div>
<div class="line"><span class="comment">// We assume that &quot;chunk&quot; has already been initialized somewhere</span></div>
<div class="line">decompr = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) *</div>
<div class="line">                 <a class="code" href="group__poly__lowlevel.html#ga141568816a3a902b8575be472e63ea4b">pcomp_chunk_num_of_samples</a>(chunk));</div>
<div class="line"></div>
<div class="line">inv_chebyshev = <a class="code" href="group__cheby.html#ga4b7e004c7b6735e6b026cfd81d30c993">pcomp_init_chebyshev</a>(input_size,</div>
<div class="line">                                     <a class="code" href="group__poly.html#gga916be96db23ae0292046887134631acaa78888ceb661c6d947c9df1b7b16830a9">PCOMP_TD_INVERSE</a>);</div>
<div class="line"><a class="code" href="group__poly__lowlevel.html#gae2227fe2823fe2ce04d9c1a1d99dc294">pcomp_decompress_polycomp_chunk</a>(decompr, chunk, inv_chebyshev);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to the array that will contain the uncompressed data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>The chunk to decompress</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inv_chebyshev</td><td>Pointer to a pcomp_chebyshev_t object that performs the inverse Chebyshev transform. The function does not allocate an object of this kind because in this way such objects can be reused on subsequent calls to <a class="el" href="group__poly__lowlevel.html#gae2227fe2823fe2ce04d9c1a1d99dc294">pcomp_decompress_polycomp_chunk</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS if no error occurred, or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01833">1833</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabf2ff8322ae622908407d94ac1873317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcomp_find_chebyshev_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *&#160;</td>
          <td class="paramname"><em>chebyshev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a> *&#160;</td>
          <td class="paramname"><em>inv_chebyshev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_allowable_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>max_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest subset of Chebyshev coefficients that can approximate a Chebyshev transform with an error less than <em>max_allowable_error</em>. </p>
<p>On exit, the bits in <em>bitmask</em> will be set to 1 in correspondence of every Chebyshev coefficient that must be retained. The function returns the number of Chebyshev coefficients to retain (i.e., the number of bits in <em>mask</em> that have been set to 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chebyshev</td><td>Pointer to a pcomp_chebyshev_t structure used to compute the forward Chebyshev transform (from the space of the fit residuals to the Chebyshev space)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inv_chebyshev</td><td>Pointer to a pcomp_chebyshev_t structure representing the inverse transform of <em>chebyshev</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_allowable_error</td><td>The maximum allowed discrepancy for the chopped Chebyshev, as measured in the space of the fit residuals.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mask</td><td>Bitmask that will contain the position of the unchopped Chebyshev terms of the transform of the fit residuals. Use <a class="el" href="group__poly__lowlevel.html#gab793c0d3bc98503acefd4c4d095ddd45">pcomp_mask_get_bit</a> to access each element.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_error</td><td>If not <code>NULL</code>, it will be set to the maximum error due to the chopping of the Chebyshev transform represented by <em>mask</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits equal to one in <em>mask</em>, i.e., the number of unchopped Chebyshev coefficients. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01522">1522</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf50ddd62f855c2dfc1bc96ff00d5749e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_free_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory associated with a pcomp_poly_chunk_t. </p>
<p>This function releases the memory allocated by one of the following functions:</p><ul>
<li><a class="el" href="group__poly__lowlevel.html#ga43fbe9e5919993793a6d6bc21052db0a">pcomp_init_chunk</a></li>
<li><a class="el" href="group__poly__lowlevel.html#ga28f80a1f4ebc88b78e077911f7609252">pcomp_init_uncompressed_chunk</a></li>
<li><a class="el" href="group__poly__lowlevel.html#ga0ff14c414978ab762b24993b7e607a2e">pcomp_init_compressed_chunk</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk</td><td>Pointer to the object to be freed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01095">1095</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga43fbe9e5919993793a6d6bc21052db0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a>* pcomp_init_chunk </td>
          <td>(</td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>num_of_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a pcomp_polycomp_chunk_t object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_samples</td><td>Number of samples that the chunk will be capable to hold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated object. Use <a class="el" href="group__poly__lowlevel.html#gaf50ddd62f855c2dfc1bc96ff00d5749e">pcomp_free_chunk</a> to free the memory once is no longer needed. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00936">936</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ff14c414978ab762b24993b7e607a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a>* pcomp_init_compressed_chunk </td>
          <td>(</td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>num_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcomp_poly_size_t&#160;</td>
          <td class="paramname"><em>num_of_poly_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>poly_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>num_of_cheby_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cheby_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>cheby_coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a pcomp_polycomp_chunk_t object and fill it with data compressed using the polynomial compression algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_samples</td><td>Number of samples that the chunk will be capable to hold.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_poly_coeffs</td><td>Number of coefficients of the interpolating polynomial.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_coeffs</td><td>Pointer to the coefficients of the interpolating polynomial. Their number must be equal to the parameter <em>num_of_poly_coeffs</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_cheby_coeffs</td><td>Number of nonzero Chebyshev coefficients associated with the polynomial fit. This number is always less than <em>num_of_samples</em>. Zero is allowed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cheby_mask</td><td>Bitmask representing the position of the nonzero coefficients in <em>cheby_coeffs</em> within the full sequence. (Use <a class="el" href="group__poly__lowlevel.html#gab793c0d3bc98503acefd4c4d095ddd45">pcomp_mask_get_bit</a> and <a class="el" href="group__poly__lowlevel.html#gad21094e8f3ade1288b47870b9c45c879">pcomp_mask_set_bit</a> to read/write bits in the sequence.)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cheby_coeffs</td><td>Array of nonzero Chebyshev coefficients. Their number must be equal to <em>num_of_cheby_coeffs</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated object. Use <a class="el" href="group__poly__lowlevel.html#gaf50ddd62f855c2dfc1bc96ff00d5749e">pcomp_free_chunk</a> to free the memory once is no longer needed. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01033">1033</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga28f80a1f4ebc88b78e077911f7609252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a>* pcomp_init_uncompressed_chunk </td>
          <td>(</td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>num_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a pcomp_polycomp_chunk_t object and fill it with data in uncompressed form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_samples</td><td>Number of samples that the chunk will be capable to hold.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The (uncompressed) samples to copy into the chunk. After the call, <em>input</em> is no longer needed and can be freed without invalidating the pointer returned by the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated object. Use <a class="el" href="group__poly__lowlevel.html#gaf50ddd62f855c2dfc1bc96ff00d5749e">pcomp_free_chunk</a> to free the memory once is no longer needed. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00975">975</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab793c0d3bc98503acefd4c4d095ddd45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_mask_get_bit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the bit at the position <em>pos</em> in the bitmask <em>mask</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Pointer to the first byte of the mask</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Zero-based index of the bit in the mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either 0 or 1, depending on the value of the bit. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01450">1450</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad21094e8f3ade1288b47870b9c45c879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_mask_set_bit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the bit at position <em>pos</em> in the bitmask <em></em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mask</td><td>The bitmask to modify</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Zero-based index of the byte to set</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the bit (either 0 or 1; any value different from zero is treated as equal to 1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01466">1466</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9af675aacf01f812bda7244f488771a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a>* pcomp_polycomp_backward_cheby </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a pcomp_chebyshev_t structure representing the forward Chebyshev transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm to be used by the compressor. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00752">752</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga18386cb1be87dc5f53c412d597496a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__chebyshev__t.html">pcomp_chebyshev_t</a>* pcomp_polycomp_forward_cheby </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a pcomp_chebyshev_t structure representing the forward Chebyshev transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm to be used by the compressor. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00733">733</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga30c82bb784b5207c2699b1db70d985ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_polyfit_and_chebyshev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cheby_residuals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>max_residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a polynomial fit of the data in <em>input</em> and a Chebyshev transform of the residuals. </p>
<p>Note that this function <em>always</em> computes the Chebyshev transform of the data, even if there is a perfect fit between the polynomial and the input data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure initialized by <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coeffs</td><td>Pointer to the array that on exit will hold the coefficients of the best-fit polynomial. It must have enough room for a number of elements equal to the return value of <a class="el" href="group__poly.html#gafa7c47c8c364e21792c92e70c7b13f95">pcomp_polycomp_num_of_poly_coeffs</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cheby_residuals</td><td>Pointer to an array that on exit will contain the Chebyshev transform of the residuals of the fit. It can be <code>NULL</code>; in any case, these numbers can be obtained by the use of a call to <a class="el" href="group__poly__lowlevel.html#ga18386cb1be87dc5f53c412d597496a56">pcomp_polycomp_forward_cheby</a> and <a class="el" href="group__cheby.html#gafe68b46cd98968a473881312e6856e09">pcomp_chebyshev_output</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to the array of values to be transformed. The number of values used is equal to the return value of the function <a class="el" href="group__poly.html#gab78e51afbc007f4a5e941cd4911ac190">pcomp_polycomp_samples_per_chunk</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_residual</td><td>Pointer to a variable that will hold the maximum absolute value of the discrepancy between each sample in <em>input</em> and the polynomial fit. It can be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If no errors occurred, PCOMP_STAT_SUCCESS. Otherwise, the function returns the code of the error. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01357">1357</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga16fd7dc37524f6a0ba57d29ca766a54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_run_polycomp_on_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>num_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>max_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the first <em>num_of_samples</em> elements in <em>input</em> and store them in <em>chunk</em>. </p>
<p>The function determines if the data in <em>input</em> can be efficiently compressed using polynomial compression with the parameters described by <em>params</em>. If it is so, it stores the compressed data in <em>chunk</em>. If the compression ratio is small or equal to one, or if the compression error is too large, the function copies the data in <em>input</em> into <em>chunk</em> in uncompressed format.</p>
<p>The following example shows how to use this function together with pcomp_init_chunk:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> input[] = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0,</div>
<div class="line">                   7.0, 8.0, 9.0, 11.0 };</div>
<div class="line"><span class="keywordtype">size_t</span> input_size = <span class="keyword">sizeof</span>(input) / <span class="keyword">sizeof</span>(input[0]);</div>
<div class="line"><a class="code" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a>* chunk;</div>
<div class="line"><a class="code" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a>* polycomp;</div>
<div class="line"><span class="keywordtype">double</span> max_error;</div>
<div class="line"><span class="keywordtype">size_t</span> idx;</div>
<div class="line"></div>
<div class="line">polycomp = <a class="code" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>(input_size, 2, 1.0e-5,</div>
<div class="line">                               <a class="code" href="group__poly.html#gga1bc63ccaec65919ae95887c08e83eb6ba896a47692787ffdd9e291447b82ca6ff">PCOMP_ALG_USE_CHEBYSHEV</a>);</div>
<div class="line">chunk = <a class="code" href="group__poly__lowlevel.html#ga43fbe9e5919993793a6d6bc21052db0a">pcomp_init_chunk</a>(input_size);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__poly__lowlevel.html#ga16fd7dc37524f6a0ba57d29ca766a54d">pcomp_run_polycomp_on_chunk</a>(polycomp, input, input_size, chunk,</div>
<div class="line">                            &amp;max_error);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a <em>pcomp_polycomp_t</em> structure (created using <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>) which provides the parameters of the compression.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The sequence of numbers to compress. Their number is equal to the parameter <em>num_of_samples</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_samples</td><td>Number of values in <em>input</em> to compress</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">chunk</td><td>The chunk that will contain the data, either in compressed or uncompressed format. It must have already been initialized via a call to <a class="el" href="group__poly__lowlevel.html#ga43fbe9e5919993793a6d6bc21052db0a">pcomp_init_chunk</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_error</td><td>On exit, the function writes the compression error here. It can be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS (if no errors occurred), or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01666">1666</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf29ad7a7a070d4e13bc7ab2788b914a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_straighten </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sudden jumps from <em>input</em>. </p>
<p>Assuming that the data in the array <em>input</em> have a periodicity equal to <em>period</em>, the function copies them to <em>output</em> while applying a positive/negative offset equal to a multiple of <em>period</em>.</p>
<p>It is ok for <em>input</em> and <em>output</em> to point to the same memory location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to the array that will contain the result. It must have room for at least <em>num_of_samples</em> values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Array of <em>num_of_samples</em> values to process.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_samples</td><td>Number of samples to process in <em>input</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Periodicity of the data. If less or equal to zero, <em>input</em> is copied verbatim to <em>output</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00864">864</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 27 2015 09:46:37 for Libpolycomp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
