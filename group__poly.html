<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Libpolycomp: Polynomial compression functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libpolycomp
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A compression/decompression library that implements the polynomial compression and other simple compression schemes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__poly.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polynomial compression functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga916be96db23ae0292046887134631aca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga916be96db23ae0292046887134631aca">pcomp_transform_direction_t</a> { <a class="el" href="group__poly.html#gga916be96db23ae0292046887134631acaaf8dce6961ca63dc3a46dc81b99be0d5d">PCOMP_TD_DIRECT</a> = 0, 
<a class="el" href="group__poly.html#gga916be96db23ae0292046887134631acaa78888ceb661c6d947c9df1b7b16830a9">PCOMP_TD_INVERSE</a> = 1
 }</td></tr>
<tr class="memdesc:ga916be96db23ae0292046887134631aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction of a Chebyshev transform.  <a href="group__poly.html#ga916be96db23ae0292046887134631aca">More...</a><br /></td></tr>
<tr class="separator:ga916be96db23ae0292046887134631aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc63ccaec65919ae95887c08e83eb6b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a> { <a class="el" href="group__poly.html#gga1bc63ccaec65919ae95887c08e83eb6ba896a47692787ffdd9e291447b82ca6ff">PCOMP_ALG_USE_CHEBYSHEV</a> = 0, 
<a class="el" href="group__poly.html#gga1bc63ccaec65919ae95887c08e83eb6ba7fdc02ed16c84d1da93721e5c4c0fc0a">PCOMP_ALG_NO_CHEBYSHEV</a> = 1
 }</td></tr>
<tr class="memdesc:ga1bc63ccaec65919ae95887c08e83eb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of algorithm used for the polynomial compression.  <a href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">More...</a><br /></td></tr>
<tr class="separator:ga1bc63ccaec65919ae95887c08e83eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3192eb47cac9f94936f283fcc2dccf74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a> (pcomp_chunk_size_t samples_per_chunk, pcomp_poly_size_t num_of_coeffs, double max_allowable_error, <a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a> algorithm)</td></tr>
<tr class="memdesc:ga3192eb47cac9f94936f283fcc2dccf74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a pcomp_polycomp_t structure.  <a href="#ga3192eb47cac9f94936f283fcc2dccf74">More...</a><br /></td></tr>
<tr class="separator:ga3192eb47cac9f94936f283fcc2dccf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abae32ef61a1a8a0f73b2ccdb0667a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga5abae32ef61a1a8a0f73b2ccdb0667a7">pcomp_free_polycomp</a> (<a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga5abae32ef61a1a8a0f73b2ccdb0667a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory allocated by <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a> for a pcomp_polycomp_t structure.  <a href="#ga5abae32ef61a1a8a0f73b2ccdb0667a7">More...</a><br /></td></tr>
<tr class="separator:ga5abae32ef61a1a8a0f73b2ccdb0667a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78e51afbc007f4a5e941cd4911ac190"><td class="memItemLeft" align="right" valign="top">pcomp_chunk_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gab78e51afbc007f4a5e941cd4911ac190">pcomp_polycomp_samples_per_chunk</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:gab78e51afbc007f4a5e941cd4911ac190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of samples per chunk.  <a href="#gab78e51afbc007f4a5e941cd4911ac190">More...</a><br /></td></tr>
<tr class="separator:gab78e51afbc007f4a5e941cd4911ac190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7c47c8c364e21792c92e70c7b13f95"><td class="memItemLeft" align="right" valign="top">pcomp_poly_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gafa7c47c8c364e21792c92e70c7b13f95">pcomp_polycomp_num_of_poly_coeffs</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:gafa7c47c8c364e21792c92e70c7b13f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of coefficients for the fitting polynomial used in the polynomial compression.  <a href="#gafa7c47c8c364e21792c92e70c7b13f95">More...</a><br /></td></tr>
<tr class="separator:gafa7c47c8c364e21792c92e70c7b13f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8672475e686bc31189cb096234f6737"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gad8672475e686bc31189cb096234f6737">pcomp_polycomp_max_error</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:gad8672475e686bc31189cb096234f6737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper bound on the error of the polynomial compression.  <a href="#gad8672475e686bc31189cb096234f6737">More...</a><br /></td></tr>
<tr class="separator:gad8672475e686bc31189cb096234f6737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348ae5dd69b4c9fac6ed7b16df414b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga348ae5dd69b4c9fac6ed7b16df414b07">pcomp_polycomp_algorithm</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga348ae5dd69b4c9fac6ed7b16df414b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of algorithm used for a polynomial compression.  <a href="#ga348ae5dd69b4c9fac6ed7b16df414b07">More...</a><br /></td></tr>
<tr class="separator:ga348ae5dd69b4c9fac6ed7b16df414b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c17d9420262cdb765aa07554dcd13a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga18c17d9420262cdb765aa07554dcd13a">pcomp_polycomp_period</a> (const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga18c17d9420262cdb765aa07554dcd13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the period of the input data, or a number less than or equal to 0 if the data have no periodicity.  <a href="#ga18c17d9420262cdb765aa07554dcd13a">More...</a><br /></td></tr>
<tr class="separator:ga18c17d9420262cdb765aa07554dcd13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ca2f9b0748609a25ff8b9016093a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gac8ca2f9b0748609a25ff8b9016093a88">pcomp_polycomp_set_period</a> (<a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params, double period)</td></tr>
<tr class="memdesc:gac8ca2f9b0748609a25ff8b9016093a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the periodicity of the data to be compressed.  <a href="#gac8ca2f9b0748609a25ff8b9016093a88">More...</a><br /></td></tr>
<tr class="separator:gac8ca2f9b0748609a25ff8b9016093a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87725918ac9dc89d532647768dc0a812"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> **output_buf[], size_t *num_of_chunks, const double *input_buf, size_t input_size, const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *params)</td></tr>
<tr class="memdesc:ga87725918ac9dc89d532647768dc0a812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the array <em>input_buf</em> using polynomial compression.  <a href="#ga87725918ac9dc89d532647768dc0a812">More...</a><br /></td></tr>
<tr class="separator:ga87725918ac9dc89d532647768dc0a812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c5b17fd5d5dac2e23d19ae3e8ad9ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gad9c5b17fd5d5dac2e23d19ae3e8ad9ee">pcomp_total_num_of_samples</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const chunk_array[], size_t num_of_chunks)</td></tr>
<tr class="memdesc:gad9c5b17fd5d5dac2e23d19ae3e8ad9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the number of samples encoded in <em>chunk_array</em>.  <a href="#gad9c5b17fd5d5dac2e23d19ae3e8ad9ee">More...</a><br /></td></tr>
<tr class="separator:gad9c5b17fd5d5dac2e23d19ae3e8ad9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec113fa0273bc8207942f8f763d4d202"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gaec113fa0273bc8207942f8f763d4d202">pcomp_decompress_polycomp</a> (double *output_buf, <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const chunk_array[], size_t num_of_chunks)</td></tr>
<tr class="memdesc:gaec113fa0273bc8207942f8f763d4d202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompress a sequence of chunks.  <a href="#gaec113fa0273bc8207942f8f763d4d202">More...</a><br /></td></tr>
<tr class="separator:gaec113fa0273bc8207942f8f763d4d202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0daad245f72a0857d0ecf1632b0af1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga0daad245f72a0857d0ecf1632b0af1ed">pcomp_free_chunks</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *chunk_array[], size_t num_of_chunks)</td></tr>
<tr class="memdesc:ga0daad245f72a0857d0ecf1632b0af1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an array of chunks.  <a href="#ga0daad245f72a0857d0ecf1632b0af1ed">More...</a><br /></td></tr>
<tr class="separator:ga0daad245f72a0857d0ecf1632b0af1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da3460a4c6e8fdabd4fca9ab155888c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga9da3460a4c6e8fdabd4fca9ab155888c">pcomp_chunks_num_of_bytes</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const chunks[], size_t num_of_chunks)</td></tr>
<tr class="memdesc:ga9da3460a4c6e8fdabd4fca9ab155888c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes required by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>.  <a href="#ga9da3460a4c6e8fdabd4fca9ab155888c">More...</a><br /></td></tr>
<tr class="separator:ga9da3460a4c6e8fdabd4fca9ab155888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb33574b0b28724ec6785bfe7e240d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a> (void *buf, size_t *buf_size, <a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const chunk_array[], size_t num_of_chunks)</td></tr>
<tr class="memdesc:gafdb33574b0b28724ec6785bfe7e240d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a list of chunks into a sequence of raw bytes.  <a href="#gafdb33574b0b28724ec6785bfe7e240d2">More...</a><br /></td></tr>
<tr class="separator:gafdb33574b0b28724ec6785bfe7e240d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388baf20639fc3adca5debcf62f03046"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poly.html#ga388baf20639fc3adca5debcf62f03046">pcomp_decode_chunks</a> (<a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> **chunk_array[], size_t *num_of_chunks, const void *buf)</td></tr>
<tr class="memdesc:ga388baf20639fc3adca5debcf62f03046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a byte sequence created by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a> into an array of chunks.  <a href="#ga388baf20639fc3adca5debcf62f03046">More...</a><br /></td></tr>
<tr class="separator:ga388baf20639fc3adca5debcf62f03046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Polynomial compression relies on a simple idea, that is to divide the input data stream into subsets of consecutive samples (called "chunks"), and to approximate each chunk by means of a polynomial. Such compression is inherently lossy, as the residuals of the fitting procedure are usually discarded. If the polynomial used for the fitting produces residuals that are too large, usually the samples in the chunk are saved in uncompressed form.</p>
<p>This idea has been widely applied in the literature. Libpolycomp implements an improvement over it, because if the fit residuals are too large, the library saves a chopped sequence of the Chebyshev transform of the residuals. This allows to achieve better compression ratios in those cases where polynomial fitting is not always enough to keep compression errors below the desired threshold. This kind of compression works quite well for smooth data series, where changes between consecutive samples are well described by slowly varying continuous functions. It is not suitable if the signal contains noise, unless this noise is significantly smaller than the signal and than the error threshold.</p>
<p>Libpolycomp allows to avoid the usage of Chebyshev transforms. In this case, if no polynomial of the desired degree are able to fit the data with the given error threshold, the data for that chunk is saved uncompressed.</p>
<p>The typical workflow for applying polynomial compression is the following:</p>
<ol type="1">
<li>Allocate a new pcomp_polycomp_t object via a call to <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>. Such object contains the parameters to be used for the compression, e.g., the size of each chunk, the degree of the fitting polynomial, whether to apply or not the Chebyshev transform to the residuals, etc.</li>
<li>Split the data into chunks and compress each of them using the function <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</li>
<li>Convert the list of chunks into a byte sequence using <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>, typically with the purpose of saving it into a file or sending it through a pipe/socket/etc.</li>
</ol>
<p>The decompression workflow is specular:</p>
<ol type="1">
<li>Process the byte sequence containing the compressed data using <a class="el" href="group__poly.html#ga388baf20639fc3adca5debcf62f03046">pcomp_decode_chunks</a>. This will produce a list of chunks that are still compressed.</li>
<li>Decompress the chunks using the function <a class="el" href="group__poly.html#gaec113fa0273bc8207942f8f763d4d202">pcomp_decompress_polycomp</a>.</li>
</ol>
<p>The compression functions described in this page use the pcomp_polycomp_t structure to determine which parameters to use for the compression. The functions that allow to allocate/free/manage this structure are the following:</p>
<ul>
<li><a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a> and <a class="el" href="group__poly.html#ga5abae32ef61a1a8a0f73b2ccdb0667a7">pcomp_free_polycomp</a></li>
<li><a class="el" href="group__poly.html#gab78e51afbc007f4a5e941cd4911ac190">pcomp_polycomp_samples_per_chunk</a></li>
<li><a class="el" href="group__poly.html#gafa7c47c8c364e21792c92e70c7b13f95">pcomp_polycomp_num_of_poly_coeffs</a></li>
<li><a class="el" href="group__poly.html#gad8672475e686bc31189cb096234f6737">pcomp_polycomp_max_error</a></li>
<li><a class="el" href="group__poly.html#ga348ae5dd69b4c9fac6ed7b16df414b07">pcomp_polycomp_algorithm</a></li>
<li><a class="el" href="group__poly.html#ga18c17d9420262cdb765aa07554dcd13a">pcomp_polycomp_period</a> and <a class="el" href="group__poly.html#gac8ca2f9b0748609a25ff8b9016093a88">pcomp_polycomp_set_period</a></li>
</ul>
<p>It is possible to use a set of more low-level functions to use polynomial compression. Refer to <a class="el" href="group__poly__lowlevel.html">Polynomial compression (low-level functions)</a> for further information. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1bc63ccaec65919ae95887c08e83eb6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kind of algorithm used for the polynomial compression. </p>
<p>See the discussion in the section <a class="el" href="group__poly.html">Polynomial compression functions</a> for more information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1bc63ccaec65919ae95887c08e83eb6ba896a47692787ffdd9e291447b82ca6ff"></a>PCOMP_ALG_USE_CHEBYSHEV&#160;</td><td class="fielddoc">
<p>When needed, apply the Chebyshev transform to the residuals of the polynomial fit. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1bc63ccaec65919ae95887c08e83eb6ba7fdc02ed16c84d1da93721e5c4c0fc0a"></a>PCOMP_ALG_NO_CHEBYSHEV&#160;</td><td class="fielddoc">
<p>If the absolute value of the residuals of a polynomial fit are too large, store the data in uncompressed form. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="libpolycomp_8h_source.html#l00355">355</a> of file <a class="el" href="libpolycomp_8h_source.html">libpolycomp.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga916be96db23ae0292046887134631aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__poly.html#ga916be96db23ae0292046887134631aca">pcomp_transform_direction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direction of a Chebyshev transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga916be96db23ae0292046887134631acaaf8dce6961ca63dc3a46dc81b99be0d5d"></a>PCOMP_TD_DIRECT&#160;</td><td class="fielddoc">
<p>Compute a forward Chebyshev transform, with a normalization factor 1/(N + 1) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga916be96db23ae0292046887134631acaa78888ceb661c6d947c9df1b7b16830a9"></a>PCOMP_TD_INVERSE&#160;</td><td class="fielddoc">
<p>Compute a backward Chebyshev transform, with a normalization factor equal to one. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="libpolycomp_8h_source.html#l00320">320</a> of file <a class="el" href="libpolycomp_8h_source.html">libpolycomp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9da3460a4c6e8fdabd4fca9ab155888c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcomp_chunks_num_of_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const&#160;</td>
          <td class="paramname"><em>chunks</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes required by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>. </p>
<p>This function computes the number of bytes required to encode the array of chunks in the variable <em>chunks</em>. Unlike functions like <a class="el" href="group___r_l_e.html#gac092b6d2dd746e65f8a514acdc558eae">pcomp_rle_bufsize</a>, this function provides an exact estimate, not an upper bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunks</td><td>Array of chunks to encode. This should have been initialized via a call to <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_chunks</td><td>Number of elements in <em>chunks</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes required for the output buffer used by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02138">2138</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga87725918ac9dc89d532647768dc0a812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_compress_polycomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> **&#160;</td>
          <td class="paramname"><em>output_buf</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>input_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the array <em>input_buf</em> using polynomial compression. </p>
<p>This function compresses the first <em>input_size</em> elements of the array <em>input_buf</em> using the polynomial compression scheme. The output is an array of chunks saved in <em>output_buf</em> (the number of elements of this array is saved in <em>num_of_chunks</em>). The <em>params</em> variable specifies the parameters used by the compression algorithm.</p>
<p>Here is an example showing how to compress a sequence of numbers in the variable <em>input:</em> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> input[] = { 1.0, 2.0, 3.0, 4.0, 3.0, 2.0,</div>
<div class="line">                   1.0, 2.0, 6.0, 7.0, 9.0 };</div>
<div class="line"><span class="keywordtype">size_t</span> input_size = <span class="keyword">sizeof</span>(input) / <span class="keyword">sizeof</span>(input[0]);</div>
<div class="line"><span class="keywordtype">double</span>* decompr;</div>
<div class="line"><span class="keywordtype">size_t</span> decompr_size;</div>
<div class="line"><a class="code" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a>** chunks;</div>
<div class="line"><span class="keywordtype">size_t</span> num_of_chunks;</div>
<div class="line"><a class="code" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a>* params;</div>
<div class="line"><span class="keywordtype">size_t</span> idx;</div>
<div class="line"></div>
<div class="line">params = <a class="code" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>(4, 2, 1.0e-5, <a class="code" href="group__poly.html#gga1bc63ccaec65919ae95887c08e83eb6ba896a47692787ffdd9e291447b82ca6ff">PCOMP_ALG_USE_CHEBYSHEV</a>);</div>
<div class="line"><a class="code" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>(&amp;chunks, &amp;num_of_chunks, input, input_size,</div>
<div class="line">                        params);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Print some information for each chunk</span></div>
<div class="line"><span class="keywordflow">for</span>(idx = 0; idx &lt; num_of_chunks; ++idx) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Chunk %lu of %lu: %s\n&quot;</span>, idx + 1, num_of_chunks,</div>
<div class="line">           <a class="code" href="group__poly__lowlevel.html#ga6c68ca23c00d0c68290cbee421b46959">pcomp_chunk_is_compressed</a>(chunks[idx]) ?</div>
<div class="line">               <span class="stringliteral">&quot;compressed&quot;</span> : <span class="stringliteral">&quot;uncompressed&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once the sequence <em>input_buf</em> is compressed, the array of chunks can either be analyzed (e.g., using a <code>for</code> loop as in the example above) or encoded using the <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>. Once the variable <em>output_buf</em> is no longer used, it should be freed via a call to <a class="el" href="group__poly.html#ga0daad245f72a0857d0ecf1632b0af1ed">pcomp_free_chunks</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output_buf</td><td>Pointer to a variable that will receive the address of an array of pcomp_polycomp_chunk_t variables created by the function. Such array contains the whole set of data in <em>input</em> in compressed format. The array can be freed via a call to <a class="el" href="group__poly.html#ga0daad245f72a0857d0ecf1632b0af1ed">pcomp_free_chunks</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_of_chunks</td><td>On output, the variable will contain the number of chunks saved in <em>output_buf</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_buf</td><td>Pointer to the array of numbers to compress.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_size</td><td>Number of elements in <em>input_buf</em> to compress.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameters used for the compression. The variable must have been created via a call to <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS if no error occurred, or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l01951">1951</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga388baf20639fc3adca5debcf62f03046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_decode_chunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> **&#160;</td>
          <td class="paramname"><em>chunk_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a byte sequence created by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a> into an array of chunks. </p>
<p>This function can be used to read from a binary file or a socket a sequence of chunks encoded by <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>. The function allocates memory for an array of pcomp_polycomp_chunk_t structures and returns it in the variable <em>chunk_array</em>. The latter variable must be freed using <a class="el" href="group__poly.html#ga0daad245f72a0857d0ecf1632b0af1ed">pcomp_free_chunks</a> once it is no longer needed.</p>
<p>This function is the counterpart for <a class="el" href="group__poly.html#gafdb33574b0b28724ec6785bfe7e240d2">pcomp_encode_chunks</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">chunk_array</td><td>Pointer to an array that will contain the chunks decoded from <em>buf</em>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_of_chunks</td><td>On exit, this variable will hold the number of chunks saved in <em>chunk_array</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pointer</td><td>to the byte sequence to decode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS if no error occurred, or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02287">2287</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaec113fa0273bc8207942f8f763d4d202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_decompress_polycomp </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>output_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const&#160;</td>
          <td class="paramname"><em>chunk_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompress a sequence of chunks. </p>
<p>This function is the counterpart for <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output_buf</td><td>Pointer to the variable that will hold the uncompressed data. It must have room for a number of elements at least equal to the return value of <a class="el" href="group__poly.html#gad9c5b17fd5d5dac2e23d19ae3e8ad9ee">pcomp_total_num_of_samples</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_array</td><td>Array of chunks holding the data in compressed format.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_chunks</td><td>Number of elements in the array <em>chunk_array</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS if no error occurred, or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02059">2059</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafdb33574b0b28724ec6785bfe7e240d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pcomp_encode_chunks </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const&#160;</td>
          <td class="paramname"><em>chunk_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a list of chunks into a sequence of raw bytes. </p>
<p>This function transforms an array of instances to pcomp_polycomp_chunk_t variables into a sequence of raw bytes, suitable for I/O. It can be used together with <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a> to compress a dataset and save it into a binary file.</p>
<p>To decode byte sequences produced by this function, use <a class="el" href="group__poly.html#ga388baf20639fc3adca5debcf62f03046">pcomp_decode_chunks</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to a memory buffer that will receive the result of the encoding. It must have room for a number of bytes (<code>uint8_t</code>) at least equal to the return value of <a class="el" href="group__poly.html#ga9da3460a4c6e8fdabd4fca9ab155888c">pcomp_chunks_num_of_bytes</a>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_size</td><td>On input, it should contain the number of bytes that can be written in <em>buf</em>. On exit, it will contain the number of bytes actually written. The latter number is equal to the value returned by <a class="el" href="group__poly.html#ga9da3460a4c6e8fdabd4fca9ab155888c">pcomp_chunks_num_of_bytes</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_array</td><td>Array of chunks to encode</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_chunks</td><td>Number of elements in the array <em>chunk_array</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either PCOMP_STAT_SUCCESS if no error occurred, or the error code. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02193">2193</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0daad245f72a0857d0ecf1632b0af1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_free_chunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *&#160;</td>
          <td class="paramname"><em>chunk_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an array of chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_array</td><td>An array of chunks. This variable must have been allocated by a call to <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_chunks</td><td>Number of elements in the array <em>chunk_array</em> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02106">2106</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5abae32ef61a1a8a0f73b2ccdb0667a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_free_polycomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory allocated by <a class="el" href="group__poly.html#ga3192eb47cac9f94936f283fcc2dccf74">pcomp_init_polycomp</a> for a pcomp_polycomp_t structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to the structure to be freed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00628">628</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3192eb47cac9f94936f283fcc2dccf74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a>* pcomp_init_polycomp </td>
          <td>(</td>
          <td class="paramtype">pcomp_chunk_size_t&#160;</td>
          <td class="paramname"><em>samples_per_chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcomp_poly_size_t&#160;</td>
          <td class="paramname"><em>num_of_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_allowable_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for a pcomp_polycomp_t structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">samples_per_chunk</td><td>Number of samples in each chunk</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_coeffs</td><td>Number of polynomial coefficients to use</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_allowable_error</td><td>Upper bound for the compression error (positive value)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>Kind of compression algorithm to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocate pcomp_polycomp_t structure. This must be freed using <a class="el" href="group__poly.html#ga5abae32ef61a1a8a0f73b2ccdb0667a7">pcomp_free_polycomp</a>, once it is no longer used. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00598">598</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga348ae5dd69b4c9fac6ed7b16df414b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__poly.html#ga1bc63ccaec65919ae95887c08e83eb6b">pcomp_polycomp_algorithm_t</a> pcomp_polycomp_algorithm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the kind of algorithm used for a polynomial compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The algorithm to be used by the compressor. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00714">714</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad8672475e686bc31189cb096234f6737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pcomp_polycomp_max_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the upper bound on the error of the polynomial compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowable error for the polynomial compression. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00695">695</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafa7c47c8c364e21792c92e70c7b13f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcomp_poly_size_t pcomp_polycomp_num_of_poly_coeffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of coefficients for the fitting polynomial used in the polynomial compression. </p>
<p>The return value has the same meaning as the value returned by the <a class="el" href="group__polyfit.html#gafeec2bb424071797103a20b21d16922c">pcomp_poly_fit_num_of_coeffs</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of coefficients of the fitting polynomial. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00677">677</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga18c17d9420262cdb765aa07554dcd13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pcomp_polycomp_period </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the period of the input data, or a number less than or equal to 0 if the data have no periodicity. </p>
<p>See also <a class="el" href="group__poly.html#gac8ca2f9b0748609a25ff8b9016093a88">pcomp_polycomp_set_period</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The periodicity. If zero or negative, no periodicity is assumed in the data to be compressed. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00773">773</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab78e51afbc007f4a5e941cd4911ac190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcomp_chunk_size_t pcomp_polycomp_samples_per_chunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of samples per chunk. </p>
<p>This function returns the size of each chunk but the last one in the input data for a polynomial compression. Such chunks contain a set of consecutive values in the input array passed to routines as <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples in each chunk. </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00655">655</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac8ca2f9b0748609a25ff8b9016093a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcomp_polycomp_set_period </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__t.html">pcomp_polycomp_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the periodicity of the data to be compressed. </p>
<p>If <em>period</em> is a value greater than zero, this is assumed to be the periodicity of the input data: the value <em>x</em> is therefore assumed equivalent to <em>x</em> + <em>period</em> and to <em>x</em> - <em>period</em>. It is typically a multiple of Pi = 3.14159...</p>
<p>The polynomial compressor can improve the compression ratio for data if they have some form of periodicity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Pointer to a pcomp_polycomp_t structure containing the compression parameters</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The periodicity of the data, or a zero/negative value if no periodicity should be assumed by the compressor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l00799">799</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad9c5b17fd5d5dac2e23d19ae3e8ad9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pcomp_total_num_of_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct____pcomp__polycomp__chunk__t.html">pcomp_polycomp_chunk_t</a> *const&#160;</td>
          <td class="paramname"><em>chunk_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_of_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the sum of the number of samples encoded in <em>chunk_array</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chunk_array</td><td>Array of pcomp_polycomp_chunk_t variables. Typically, such array is created via a call to <a class="el" href="group__poly.html#ga87725918ac9dc89d532647768dc0a812">pcomp_compress_polycomp</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_chunks</td><td>Number of elements in <em>chunk_array</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The overall number of samples encoded in the sequence of chunks </dd></dl>

<p>Definition at line <a class="el" href="poly_8c_source.html#l02022">2022</a> of file <a class="el" href="poly_8c_source.html">poly.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 27 2015 09:46:37 for Libpolycomp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
